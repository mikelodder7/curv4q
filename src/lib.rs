#![cfg_attr(docsrs, feature(doc_auto_cfg))]

#[allow(non_snake_case)]
#[allow(non_camel_case_types)]
#[allow(dead_code)]
mod c_api {
    include!(concat!(env!("OUT_DIR"), "/bindings.rs"));
}

mod fourq {
    #![warn(
        missing_docs,
        missing_debug_implementations,
        trivial_numeric_casts,
        unused,
        clippy::mod_module_files
    )]
    #![deny(clippy::unwrap_used)]

    use super::c_api;
    use core::hash::{Hash, Hasher};
    use signature::Signer;
    use subtle::{Choice, ConditionallySelectable, ConstantTimeEq};
    #[cfg(target_arch = "wasm32")]
    use wasm_bindgen::prelude::*;
    use zeroize::{Zeroize, ZeroizeOnDrop};

    macro_rules! point_to_ptr {
        ($point:expr) => {
            &$point as *const [c_api::point_affine; 1] as *mut c_api::point_affine
        };
    }

    /// Errors generated by FourQ operations
    #[derive(Debug, Default, thiserror::Error)]
    pub enum Error {
        /// The default error
        #[default]
        #[error("An error occurred")]
        Error, // 0x00
        /// The operation was successful
        #[error("Success")]
        Success, // 0x01
        /// An error occurred during testing
        #[error("During test")]
        DuringTest, // 0x02
        /// An unknown error occurred
        #[error("Unknown error")]
        Unknown, // 0x03
        /// The operation is not implemented
        #[error("Not implemented")]
        NotImplemented, // 0x04
        /// There is not enough memory to complete the operation
        #[error("Out of memory")]
        NoMemory, // 0x05
        /// An invalid parameter was passed to the function
        #[error("Invalid parameter")]
        InvalidParameter, // 0x06
        /// The shared key is invalid
        #[error("Invalid shared key")]
        SharedKey, // 0x07
        /// The signature verification failed
        #[error("Signature verification failed")]
        SignatureVerification, // 0x08
        /// The hash to curve operation failed
        #[error("Hash to curve failed")]
        HashToCurve, // 0x09
    }

    impl From<c_api::ECCRYPTO_STATUS> for Error {
        fn from(value: c_api::ECCRYPTO_STATUS) -> Self {
            match value {
                c_api::ECCRYPTO_STATUS_ECCRYPTO_ERROR => Error::Error,
                c_api::ECCRYPTO_STATUS_ECCRYPTO_SUCCESS => Error::Success,
                c_api::ECCRYPTO_STATUS_ECCRYPTO_ERROR_DURING_TEST => Error::DuringTest,
                c_api::ECCRYPTO_STATUS_ECCRYPTO_ERROR_UNKNOWN => Error::Unknown,
                c_api::ECCRYPTO_STATUS_ECCRYPTO_ERROR_NOT_IMPLEMENTED => Error::NotImplemented,
                c_api::ECCRYPTO_STATUS_ECCRYPTO_ERROR_NO_MEMORY => Error::NoMemory,
                c_api::ECCRYPTO_STATUS_ECCRYPTO_ERROR_INVALID_PARAMETER => Error::InvalidParameter,
                c_api::ECCRYPTO_STATUS_ECCRYPTO_ERROR_SHARED_KEY => Error::SharedKey,
                c_api::ECCRYPTO_STATUS_ECCRYPTO_ERROR_SIGNATURE_VERIFICATION => {
                    Error::SignatureVerification
                }
                c_api::ECCRYPTO_STATUS_ECCRYPTO_ERROR_HASH_TO_CURVE => Error::HashToCurve,
                _ => Error::Unknown,
            }
        }
    }

    /// Represents a value for the curve
    #[derive(Debug, Default, Clone, Copy)]
    #[cfg_attr(target_arch = "wasm32", wasm_bindgen)]
    pub struct Scalar(pub [u8; 32]);

    impl From<&[u8; 32]> for Scalar {
        fn from(bytes: &[u8; 32]) -> Self {
            Self(*bytes)
        }
    }

    impl From<[u8; 32]> for Scalar {
        fn from(bytes: [u8; 32]) -> Self {
            Self(bytes)
        }
    }

    impl Hash for Scalar {
        fn hash<H: Hasher>(&self, state: &mut H) {
            self.0.hash(state);
        }
    }

    impl Eq for Scalar {}

    impl PartialEq for Scalar {
        fn eq(&self, other: &Self) -> bool {
            self.0.ct_eq(&other.0).into()
        }
    }

    impl ConstantTimeEq for Scalar {
        fn ct_eq(&self, other: &Self) -> subtle::Choice {
            self.0.ct_eq(&other.0)
        }
    }

    impl ConditionallySelectable for Scalar {
        fn conditional_select(a: &Self, b: &Self, choice: Choice) -> Self {
            let mut res = [0u8; 32];
            for (i, r) in res.iter_mut().enumerate() {
                *r = u8::conditional_select(&a.0[i], &b.0[i], choice);
            }
            Self(res)
        }
    }

    #[cfg(feature = "serde")]
    impl serdect::serde::Serialize for Scalar {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: serdect::serde::Serializer,
        {
            serdect::slice::serialize_hex_lower_or_bin(&self.0, serializer)
        }
    }

    #[cfg(feature = "serde")]
    impl<'de> serdect::serde::Deserialize<'de> for Scalar {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: serdect::serde::Deserializer<'de>,
        {
            let mut bytes = [0u8; 32];
            serdect::slice::deserialize_hex_or_bin(deserializer, &mut bytes)?;
            Ok(Scalar(bytes))
        }
    }

    impl Scalar {
        /// The number of bytes in the scalar
        pub const BYTES: usize = 32;

        /// Conver this [`Scalar`] to a byte array
        pub fn to_bytes(self) -> [u8; 32] {
            self.0
        }

        /// Convert this [`Scalar`] to a byte reference
        pub fn as_bytes(&self) -> &[u8; 32] {
            &self.0
        }
    }

    /// Represents a compressed point on the curve
    /// which is the `Y` coordinate and a sign bit in the MSB
    #[derive(Debug, Default, Clone, Copy)]
    #[cfg_attr(target_arch = "wasm32", wasm_bindgen)]
    pub struct CompressedPoint(pub [u8; 32]);

    impl From<&[u8; 32]> for CompressedPoint {
        fn from(bytes: &[u8; 32]) -> Self {
            Self(*bytes)
        }
    }

    impl From<[u8; 32]> for CompressedPoint {
        fn from(bytes: [u8; 32]) -> Self {
            Self(bytes)
        }
    }

    impl Hash for CompressedPoint {
        fn hash<H: Hasher>(&self, state: &mut H) {
            self.0.hash(state);
        }
    }

    impl Eq for CompressedPoint {}

    impl PartialEq for CompressedPoint {
        fn eq(&self, other: &Self) -> bool {
            self.0.ct_eq(&other.0).into()
        }
    }

    impl ConstantTimeEq for CompressedPoint {
        fn ct_eq(&self, other: &Self) -> subtle::Choice {
            self.0.ct_eq(&other.0)
        }
    }

    impl ConditionallySelectable for CompressedPoint {
        fn conditional_select(a: &Self, b: &Self, choice: Choice) -> Self {
            let mut res = [0u8; 32];
            for (i, r) in res.iter_mut().enumerate() {
                *r = u8::conditional_select(&a.0[i], &b.0[i], choice);
            }
            Self(res)
        }
    }

    #[cfg(feature = "serde")]
    impl serdect::serde::Serialize for CompressedPoint {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: serdect::serde::Serializer,
        {
            serdect::slice::serialize_hex_lower_or_bin(&self.0, serializer)
        }
    }

    #[cfg(feature = "serde")]
    impl<'de> serdect::serde::Deserialize<'de> for CompressedPoint {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: serdect::serde::Deserializer<'de>,
        {
            let mut bytes = [0u8; 32];
            serdect::slice::deserialize_hex_or_bin(deserializer, &mut bytes)?;
            Ok(CompressedPoint(bytes))
        }
    }

    impl CompressedPoint {
        /// The number of bytes in the compresed point
        pub const BYTES: usize = 32;

        /// Conver this [`CompressedPoint`] to a byte array
        pub fn to_bytes(self) -> [u8; 32] {
            self.0
        }

        /// Convert this [`CompressedPoint`] to a byte reference
        pub fn as_bytes(&self) -> &[u8; 32] {
            &self.0
        }
    }

    /// Represents a point on the curve
    #[derive(Debug, Default, Clone, Copy, Hash, PartialEq, Eq)]
    #[cfg_attr(target_arch = "wasm32", wasm_bindgen)]
    pub struct Point {
        point: c_api::point_t,
    }

    impl Point {
        /// Map a 16-byte value to a point on the curve
        pub fn hash_to_point(bytes: &[u8; 16]) -> Point {
            let point = [c_api::point_affine::default()];
            unsafe {
                let r0 = bytes.as_ptr() as *mut [u64; 2];
                let r1 = r0.add(1);
                c_api::mod1271(r0 as *mut u64);
                c_api::mod1271(r1 as *mut u64);
                c_api::HashToCurve(r0, point_to_ptr!(point));
            }
            Point { point }
        }

        /// Return the generator point
        pub fn generator() -> Point {
            let point = [c_api::point_affine::default()];

            unsafe {
                c_api::eccset(point_to_ptr!(point));
            }

            Point { point }
        }

        /// Compute `self` + `other`
        pub fn addition(&self, other: &Self) -> Point {
            let mut lhs = [self.to_r1()];
            let mut rhs = [other.to_r1()];
            let mut out = [c_api::point_extproj::default()];
            let mut arg1 = [c_api::point_extproj_precomp::default()];
            let mut arg2 = [c_api::point_extproj_precomp::default()];
            let point = [c_api::point_affine::default()];

            unsafe {
                c_api::R1_to_R3(lhs.as_mut_ptr(), arg1.as_mut_ptr());
                c_api::R1_to_R3(rhs.as_mut_ptr(), arg2.as_mut_ptr());
                c_api::eccadd_core(arg1.as_mut_ptr(), arg2.as_mut_ptr(), out.as_mut_ptr());
                c_api::eccnorm(out.as_mut_ptr(), point_to_ptr!(point));
            };

            Point { point }
        }

        /// Double this [`Point`]
        pub fn double(&self) -> Point {
            let mut lhs = [self.to_r1()];
            let point = [c_api::point_affine::default()];

            unsafe {
                c_api::eccdouble(lhs.as_mut_ptr());
                c_api::eccnorm(lhs.as_mut_ptr(), point_to_ptr!(point));
            };

            Point { point }
        }

        fn to_r1(self) -> c_api::point_extproj {
            let mut point = self.point;
            let mut result = c_api::point_extproj::default();
            let mut one = [[1u64, 0u64], [0u64, 0u64]];

            unsafe {
                c_api::fp2copy1271(point[0].x.as_mut_ptr(), result.x.as_mut_ptr());
                c_api::fp2copy1271(point[0].y.as_mut_ptr(), result.y.as_mut_ptr());
                c_api::fp2copy1271(one.as_mut_ptr(), result.z.as_mut_ptr());
                c_api::fp2copy1271(point[0].x.as_mut_ptr(), result.ta.as_mut_ptr());
                c_api::fp2copy1271(point[0].y.as_mut_ptr(), result.tb.as_mut_ptr());
            };

            result
        }

        /// Computes P = xG where G is the base point and x is the scalar
        pub fn scalar_base_mult(x: &Scalar) -> Point {
            let result = [c_api::point_affine::default()];

            unsafe {
                c_api::ecc_mul_fixed(x.0.as_ptr() as *mut u64, point_to_ptr!(result));
            }

            Point { point: result }
        }

        /// Computes Q = xP where P=`self` is the point and x is the scalar
        pub fn scalar_mult(&self, scalar: &Scalar) -> Point {
            let result = [c_api::point_affine::default()];

            unsafe {
                c_api::ecc_mul(
                    point_to_ptr!(self.point),
                    scalar.0.as_ptr() as *mut u64,
                    point_to_ptr!(result),
                    false,
                );
            }

            Point { point: result }
        }

        /// Compress this point into its 32-byte representation
        pub fn compress(&self) -> CompressedPoint {
            let mut bytes = [0u8; 32];
            unsafe { c_api::encode(point_to_ptr!(self.point), bytes.as_mut_ptr()) }
            CompressedPoint(bytes)
        }

        /// Decompress a 32-byte representation into a point
        pub fn decompress(compressed: &CompressedPoint) -> Self {
            let point = [c_api::point_affine::default()];

            unsafe {
                c_api::decode(compressed.0.as_ptr(), point_to_ptr!(point));
            }

            Point { point }
        }
    }

    /// The SchnorrQ [`SigningKey`].
    #[derive(Clone, Default, Debug)]
    #[cfg_attr(target_arch = "wasm32", wasm_bindgen)]
    pub struct SigningKey {
        pub(crate) sk: [u8; 32],
        pub(crate) vk: [u8; 32],
    }

    impl AsRef<[u8]> for SigningKey {
        fn as_ref(&self) -> &[u8] {
            &self.sk
        }
    }

    impl ConstantTimeEq for SigningKey {
        fn ct_eq(&self, other: &Self) -> Choice {
            self.sk.ct_eq(&other.sk)
        }
    }

    impl Eq for SigningKey {}

    impl PartialEq for SigningKey {
        fn eq(&self, other: &Self) -> bool {
            self.ct_eq(other).into()
        }
    }

    impl Hash for SigningKey {
        fn hash<H: Hasher>(&self, state: &mut H) {
            self.sk.hash(state);
        }
    }

    #[cfg(feature = "serde")]
    impl serdect::serde::Serialize for SigningKey {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: serdect::serde::Serializer,
        {
            serdect::slice::serialize_hex_lower_or_bin(&self.sk, serializer)
        }
    }

    #[cfg(feature = "serde")]
    impl<'de> serdect::serde::Deserialize<'de> for SigningKey {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: serdect::serde::Deserializer<'de>,
        {
            let mut bytes = [0u8; 32];
            serdect::slice::deserialize_hex_or_bin(deserializer, &mut bytes)?;
            Ok(SigningKey::from_slice(&bytes))
        }
    }

    impl Zeroize for SigningKey {
        fn zeroize(&mut self) {
            self.sk.zeroize();
        }
    }

    impl ZeroizeOnDrop for SigningKey {}

    impl Signer<Signature> for SigningKey {
        fn try_sign(&self, msg: &[u8]) -> Result<Signature, signature::Error> {
            Ok(self.sign_raw(msg))
        }
    }

    #[cfg(feature = "digest")]
    impl<D: signature::digest::Digest<OutputSize = signature::digest::typenum::U64>>
        signature::DigestSigner<D, Signature> for SigningKey
    {
        fn try_sign_digest(&self, digest: D) -> Result<Signature, signature::Error> {
            let msg = digest.finalize();
            Ok(self.sign_raw(&msg))
        }
    }

    impl SigningKey {
        /// Generate a new [`SigningKey`] and [`VerifyingKey`]
        pub fn generate() -> (VerifyingKey, Self) {
            let mut sk = [0u8; 32];
            let mut vk = [0u8; 32];

            unsafe {
                let err = c_api::SchnorrQ_FullKeyGeneration(sk.as_mut_ptr(), vk.as_mut_ptr());
                if err != c_api::ECCRYPTO_STATUS_ECCRYPTO_SUCCESS {
                    panic!("Key generation failed");
                }
            }

            (VerifyingKey(vk), SigningKey { sk, vk })
        }

        /// Create a [`SigningKey`] from a byte sequence.
        ///
        /// This is useful for creating deterministic keys from a seed.
        pub fn from_slice(bytes: &[u8; 32]) -> Self {
            let mut vk = [0u8; 32];
            unsafe {
                let err = c_api::SchnorrQ_KeyGeneration(bytes.as_ptr(), vk.as_mut_ptr());
                if err != c_api::ECCRYPTO_STATUS_ECCRYPTO_SUCCESS {
                    panic!("Key generation failed");
                }
            }
            Self { sk: *bytes, vk }
        }

        /// Create a [`VerifyingKey`] from this [`SigningKey`].
        pub fn verifying_key(&self) -> VerifyingKey {
            VerifyingKey(self.vk)
        }

        /// Sign a `msg`
        pub fn sign_raw(&self, msg: &[u8]) -> Signature {
            let mut sig = [0u8; 64];

            unsafe {
                if c_api::SchnorrQ_Sign(
                    self.sk.as_ptr(),
                    self.vk.as_ptr(),
                    msg.as_ptr(),
                    msg.len() as u32,
                    sig.as_mut_ptr(),
                ) != c_api::ECCRYPTO_STATUS_ECCRYPTO_SUCCESS
                {
                    panic!("Signing failed");
                }
            }

            Signature(sig)
        }
    }

    /// The SchnorrQ [`VerifyingKey`].
    #[derive(Copy, Clone, Debug, Default, Eq, PartialEq, Hash)]
    #[cfg_attr(target_arch = "wasm32", wasm_bindgen)]
    pub struct VerifyingKey(pub(crate) [u8; 32]);

    impl AsRef<[u8]> for VerifyingKey {
        fn as_ref(&self) -> &[u8] {
            &self.0
        }
    }

    impl From<&SigningKey> for VerifyingKey {
        fn from(sk: &SigningKey) -> Self {
            VerifyingKey(sk.vk)
        }
    }

    #[cfg(feature = "serde")]
    impl serdect::serde::Serialize for VerifyingKey {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: serdect::serde::Serializer,
        {
            serdect::slice::serialize_hex_lower_or_bin(&self.0, serializer)
        }
    }

    #[cfg(feature = "serde")]
    impl<'de> serdect::serde::Deserialize<'de> for VerifyingKey {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: serdect::serde::Deserializer<'de>,
        {
            let mut bytes = [0u8; 32];
            serdect::slice::deserialize_hex_or_bin(deserializer, &mut bytes)?;
            Ok(VerifyingKey(bytes))
        }
    }

    impl VerifyingKey {
        /// Create a [`VerifyingKey`] from a byte sequence
        pub fn from_slice(bytes: &[u8; 32]) -> Self {
            Self(*bytes)
        }

        /// Convert this [`VerifyingKey`] to a byte array
        pub fn to_bytes(&self) -> [u8; 32] {
            self.0
        }

        /// Convert this [`VerifyingKey`] to a byte reference
        pub fn as_bytes(&self) -> &[u8; 32] {
            &self.0
        }

        /// Verify a [`Signature`] on a `msg`
        pub fn verify(&self, signature: &Signature, msg: &[u8]) -> bool {
            let mut valid = 0u32;
            unsafe {
                let err = c_api::SchnorrQ_Verify(
                    self.0.as_ptr(),
                    msg.as_ptr(),
                    msg.len() as u32,
                    signature.0.as_ptr(),
                    &mut valid,
                );
                if err != c_api::ECCRYPTO_STATUS_ECCRYPTO_SUCCESS {
                    panic!("An error occurred during signature verifying")
                }
            }
            valid == 1
        }
    }

    /// The SchnorrQ [`Signature`].
    #[derive(Copy, Clone, Debug, Eq, PartialEq, Hash)]
    #[cfg_attr(target_arch = "wasm32", wasm_bindgen)]
    pub struct Signature(pub(crate) [u8; 64]);

    impl AsRef<[u8]> for Signature {
        fn as_ref(&self) -> &[u8] {
            &self.0
        }
    }

    #[cfg(feature = "serde")]
    impl serdect::serde::Serialize for Signature {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: serdect::serde::Serializer,
        {
            serdect::slice::serialize_hex_lower_or_bin(&self.0, serializer)
        }
    }

    #[cfg(feature = "serde")]
    impl<'de> serdect::serde::Deserialize<'de> for Signature {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: serdect::serde::Deserializer<'de>,
        {
            let mut bytes = [0u8; 64];
            serdect::slice::deserialize_hex_or_bin(deserializer, &mut bytes)?;
            Ok(Signature(bytes))
        }
    }

    impl Default for Signature {
        fn default() -> Self {
            Self([0u8; 64])
        }
    }

    /// The [`SecretKey`] component for the FourQ key exchange
    #[derive(Clone, Debug, Default)]
    #[cfg_attr(target_arch = "wasm32", wasm_bindgen)]
    pub struct SecretKey {
        sk: [u8; 32],
        vk: [u8; 32],
    }

    impl AsRef<[u8]> for SecretKey {
        fn as_ref(&self) -> &[u8] {
            &self.sk
        }
    }

    impl ConstantTimeEq for SecretKey {
        fn ct_eq(&self, other: &Self) -> Choice {
            self.sk.ct_eq(&other.sk)
        }
    }

    impl Eq for SecretKey {}

    impl PartialEq for SecretKey {
        fn eq(&self, other: &Self) -> bool {
            self.ct_eq(other).into()
        }
    }

    impl Hash for SecretKey {
        fn hash<H: Hasher>(&self, state: &mut H) {
            self.sk.hash(state);
        }
    }

    impl Zeroize for SecretKey {
        fn zeroize(&mut self) {
            self.sk.zeroize();
        }
    }

    impl ZeroizeOnDrop for SecretKey {}

    impl SecretKey {
        /// Create a [`SecretKey`] from a byte sequence
        ///
        /// This is useful for creating deterministic keys from a seed.
        pub fn from_secret_bytes(bytes: &[u8; 32]) -> (PublicKey, Self) {
            let mut vk = [0u8; 32];
            unsafe {
                let err = c_api::CompressedPublicKeyGeneration(bytes.as_ptr(), vk.as_mut_ptr());
                if err != 1 {
                    panic!("Key generation failed");
                }
            }
            (PublicKey(vk), Self { sk: *bytes, vk })
        }

        /// Generate a random new [`SecretKey`] and [`PublicKey`]
        pub fn generate() -> (PublicKey, Self) {
            let mut sk = [0u8; 32];
            let mut vk = [0u8; 32];

            unsafe {
                let err = c_api::CompressedKeyGeneration(sk.as_mut_ptr(), vk.as_mut_ptr());
                if err != 1 {
                    panic!("Key generation failed");
                }
            }

            (PublicKey(vk), SecretKey { sk, vk })
        }

        /// Get the [`PublicKey`] for this [`SecretKey`]
        pub fn public_key(&self) -> PublicKey {
            PublicKey(self.vk)
        }

        /// Generate a diffie-hellman [`SharedSecret`] from this [`SecretKey`] and a [`PublicKey`].
        pub fn diffie_hellman(&self, pk: &PublicKey) -> SharedSecret {
            let mut ss = [0u8; 32];

            unsafe {
                if c_api::CompressedSecretAgreement(
                    self.sk.as_ptr(),
                    pk.0.as_ptr(),
                    ss.as_mut_ptr(),
                ) != 1
                {
                    panic!("Shared secret generation failed");
                }
            }

            SharedSecret(ss)
        }
    }

    /// The [`PublicKey`] component for the FourQ key exchange
    #[derive(Copy, Clone, Debug, Default, Eq, PartialEq, Hash)]
    #[cfg_attr(target_arch = "wasm32", wasm_bindgen)]
    pub struct PublicKey(pub(crate) [u8; 32]);

    impl AsRef<[u8]> for PublicKey {
        fn as_ref(&self) -> &[u8] {
            &self.0
        }
    }

    #[cfg(feature = "serde")]
    impl serdect::serde::Serialize for PublicKey {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: serdect::serde::Serializer,
        {
            serdect::slice::serialize_hex_lower_or_bin(&self.0, serializer)
        }
    }

    #[cfg(feature = "serde")]
    impl<'de> serdect::serde::Deserialize<'de> for PublicKey {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: serdect::serde::Deserializer<'de>,
        {
            let mut bytes = [0u8; 32];
            serdect::slice::deserialize_hex_or_bin(deserializer, &mut bytes)?;
            Ok(PublicKey(bytes))
        }
    }

    impl PublicKey {
        /// Create a [`PublicKey`] from a byte sequence
        pub fn from_bytes(bytes: &[u8; 32]) -> Self {
            Self(*bytes)
        }

        /// Convert this [`PublicKey`] to a byte array
        pub fn to_bytes(&self) -> [u8; 32] {
            self.0
        }

        /// Convert this [`PublicKey`] to a byte reference
        pub fn as_bytes(&self) -> &[u8; 32] {
            &self.0
        }
    }

    /// The [`SharedSecret`] component for the FourQ key exchange
    ///
    /// This value should not be used directly but should be used
    /// to seed a KDF to derive the actual key.
    #[derive(Clone, Debug, Default)]
    #[cfg_attr(target_arch = "wasm32", wasm_bindgen)]
    pub struct SharedSecret(pub(crate) [u8; 32]);

    impl AsRef<[u8]> for SharedSecret {
        fn as_ref(&self) -> &[u8] {
            &self.0
        }
    }

    impl Hash for SharedSecret {
        fn hash<H: Hasher>(&self, state: &mut H) {
            self.0.hash(state);
        }
    }

    impl Eq for SharedSecret {}

    impl PartialEq for SharedSecret {
        fn eq(&self, other: &Self) -> bool {
            self.0.ct_eq(&other.0).into()
        }
    }

    impl ConstantTimeEq for SharedSecret {
        fn ct_eq(&self, other: &Self) -> Choice {
            self.0.ct_eq(&other.0)
        }
    }

    impl Zeroize for SharedSecret {
        fn zeroize(&mut self) {
            self.0.zeroize();
        }
    }

    impl ZeroizeOnDrop for SharedSecret {}

    impl SharedSecret {
        /// Convert this [`SharedSecret`] to a byte array
        pub fn to_bytes(&self) -> [u8; 32] {
            self.0
        }

        /// Convert this [`SharedSecret`] to a byte reference
        pub fn as_bytes(&self) -> &[u8; 32] {
            &self.0
        }
    }

    #[cfg(test)]
    mod tests {
        use rand_core::{RngCore, SeedableRng};

        use super::*;

        #[test]
        fn signing() {
            let mut rng = rand_chacha::ChaCha8Rng::from_entropy();
            let (vk, sk) = SigningKey::generate();

            let mut msg = [0u8; 32];
            rng.fill_bytes(&mut msg);
            let signature = sk.sign_raw(&msg);
            assert!(vk.verify(&signature, &msg));
        }

        #[test]
        fn fourq_key_exchange() {
            use std::time::Instant;

            let before = Instant::now();
            let (pk1, sk1) = SecretKey::generate();
            println!("Key gen 1: {:?}", before.elapsed());
            let before = Instant::now();
            let (pk2, sk2) = SecretKey::generate();
            println!("Key gen 2: {:?}", before.elapsed());

            let before = Instant::now();
            let ss1 = sk1.diffie_hellman(&pk2);
            println!("FourQ ECDH 1: {:?}", before.elapsed());
            let before = Instant::now();
            let ss2 = sk2.diffie_hellman(&pk1);
            println!("FourQ ECDH 2: {:?}", before.elapsed());

            assert_eq!(ss1.0, ss2.0);
        }

        #[test]
        fn x25519_key_exchange() {
            use std::time::Instant;
            use x25519_dalek::{EphemeralSecret, PublicKey};

            let mut rng = rand_chacha::ChaCha8Rng::from_entropy();
            let sk1 = EphemeralSecret::random_from_rng(&mut rng);
            let pk1 = PublicKey::from(&sk1);

            let sk2 = EphemeralSecret::random_from_rng(&mut rng);
            let pk2 = PublicKey::from(&sk2);

            let before = Instant::now();
            let ss1 = sk1.diffie_hellman(&pk2);
            println!("X25519 1: {:?}", before.elapsed());
            let before = Instant::now();
            let ss2 = sk2.diffie_hellman(&pk1);
            println!("X25519 2: {:?}", before.elapsed());

            assert_eq!(ss1.as_bytes(), ss2.as_bytes());
        }
    }
}

pub use fourq::*;
